Change log:
10-08-2016 - Foreign Keys to lowest level:
-	When inserting copy non key FK's from the parent	
21-08-2016 - RERERENCE renamed to EXTERNAL_REFERENCE
16-10-2016 - EXTERNAL_REFERENCE to RERERENCE
12-07-2017 - CUBE_ID niet meer via de view
25-10-2017 - Using trigger package
13-11-2017 - Use of ROWID added / DR triggers added
10-03-2018 - Unchangeable attributes not updating.
13-09-2018 - NVL function for primary keys with a RESTRICTION_TYPE_SPEC_ATB
04-09-2019 - Sequence name to SQ_name
04-09-2019 - Drop Views and Packages
02-02-2020 - In case of create NVL for all primary keys.
[[INCLUDE,Includes/general.cgt]]
[[INCLUDE,Includes/expression.cgt]]
[[TEXT,VIEW_CHANGEABLE_ATTRIBUTE]]!CHILD(DERIVATION:0=ID)[AND]!1=Y[AND]!6=Y[[ENDTEXT]]
[[TEXT,VIEW_SELECT_PARENT_FKEYS]]
		SELECT [[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N)]]<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
		  INTO [[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N)]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
		FROM t_<<TYPE(N-1):L>>
		WHERE [[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=Y)]][[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]] = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]]
		  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];[[ENDTEXT]]
[[BODY]]-- DB VIEW DDL
--[[LOOP,SYSTEM:0=<<1>>]]
BEGIN
	FOR r_v IN (
		SELECT view_name 
		FROM user_views[[IF:1=SUPPORT]]
		WHERE SUBSTR(view_name,1,INSTR(view_name,'_',3)) = 'V_<<SYSTEM5:U>>_'[[ELSE]][[FOR,ROOT]][[IF:CHILD(SYSTEM:1=SUPPORT)]]
		WHERE NVL(SUBSTR(view_name,1,INSTR(view_name,'_',3)),' ') NOT IN ([[LOOP,SYSTEM:1=SUPPORT]]'V_<<SYSTEM5:U>>_'[[IF:!LAST]], [[ENDIF]][[ENDLOOP,SYSTEM]])[[ENDIF]][[ENDFOR]][[ENDIF]])
	LOOP
		EXECUTE IMMEDIATE 'DROP VIEW '||r_v.view_name;
	END LOOP;
	
	FOR r_p IN (
		SELECT object_name
		FROM user_procedures
		WHERE procedure_name = 'CUBE_TRG_<<1:U>>' )
	LOOP
		EXECUTE IMMEDIATE 'DROP PACKAGE '||r_p.object_name;
	END LOOP;
END;
/[[LOOP,SYSTEM_BO_TYPE]][[LOOP,BUSINESS_OBJECT_TYPE]][[LOOP,TYPE]]
CREATE OR REPLACE VIEW v_<<TYPE:L>> AS 
	SELECT[[LOOP,ATTRIBUTE]]
		<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]]
	FROM t_<<TYPE:L>>
/[[REPEAT]][[ENDLOOP,TYPE]]

CREATE OR REPLACE PACKAGE pkg_[[LOOP,TYPE]]<<TYPE1:L>>[[ENDLOOP,TYPE]]_trg IS
	FUNCTION cube_trg_<<1:L>> RETURN VARCHAR2;[[LOOP,TYPE]]
	PROCEDURE insert_<<TYPE1:L>> (p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE);
	PROCEDURE update_<<TYPE1:L>> (p_cube_rowid IN UROWID, p_<<TYPE1:L>>_old IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE, p_<<TYPE1:L>>_new IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE);
	PROCEDURE delete_<<TYPE1:L>> (p_cube_rowid IN UROWID, p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE);[[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
	PROCEDURE denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE, p_<<TYPE1:L>>_in IN v_<<TYPE:L>>%ROWTYPE);
	PROCEDURE get_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE);[[ENDIF]][[REPEAT]][[ENDLOOP,TYPE]]
END;
/
SHOW ERRORS;

CREATE OR REPLACE PACKAGE BODY pkg_[[LOOP,TYPE]]<<TYPE1:L>>[[ENDLOOP,TYPE]]_trg IS

	FUNCTION cube_trg_<<1:L>> RETURN VARCHAR2 IS
	BEGIN
		RETURN 'cube_trg_<<1:L>>';
	END;[[LOOP,TYPE]]

	PROCEDURE insert_<<TYPE1:L>> (p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE) IS
	BEGIN[[LOOP,ATTRIBUTE:CHILD(DERIVATION:0=ID)]]
		p_<<TYPE1:L>>.<<ATTRIBUTE:L>> := '[[IF,SYSTEM:0=CubeRoot]]CUBE-[[ENDIF]]<<TYPE1:U>>-' || TO_CHAR(sq_<<TYPE1:L>>.NEXTVAL,'FM[[IF,SYSTEM:!0=CubeRoot[AND]!0=CubeSys]]00000[[ENDIF]]0000000');[[ENDLOOP,ATTRIBUTE]][[LOOP,ATTRIBUTE:!CHILD(DERIVATION)[AND](1=Y[OR]3=F[OR]3=X)]]
		p_<<TYPE1:L>>.<<ATTRIBUTE:L>> := NVL(p_<<TYPE1:L>>.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE>>);[[ENDLOOP,ATTRIBUTE]][[IF:3=Y]][[IF:CHILD(ATTRIBUTE:3=F[AND]1=N)]]
		IF [[LOOP,ATTRIBUTE:3=R]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>> IS NOT NULL [[IF:!LAST]]OR [[ENDIF]][[ENDLOOP,ATTRIBUTE]] THEN
			-- Recursive[[* If root parent has FK not in PK then recursive parent allways will have it *]]
			SELECT [[LOOP,ATTRIBUTE:3=F[AND]1=N]]<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
			  INTO [[LOOP,ATTRIBUTE:3=F[AND]1=N]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]], [[ENDIF]][[ENDLOOP,ATTRIBUTE]]
			FROM t_<<TYPE:L>>
			WHERE [[LOOP,ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=Y)[OR]3=R]][[IF:3=F]]<<ATTRIBUTE:L>>[[ELSE]][[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]][[ENDIF]] = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]]
			  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];[[IF:CHILD(ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N))]]
	ELSE
		-- Parent[[TABS:+1]]<<TEXT,VIEW_SELECT_PARENT_FKEYS>>[[TABS:-1]]
			[[ENDIF]]
		END IF;[[ENDIF]][[ELSIF:CHILD(ATTRIBUTE:3=F[AND]CHILD(ATTRIBUTE_SOURCE:1=N))]]<<TEXT,VIEW_SELECT_PARENT_FKEYS>>[[ENDIF]][[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
		get_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>>);[[ENDIF]]
		INSERT INTO t_<<TYPE:L>> ([[LOOP,ATTRIBUTE]]
			<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]])
		VALUES ([[LOOP,ATTRIBUTE]]
			p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]]);
	END;

	PROCEDURE update_<<TYPE1:L>> (p_cube_rowid UROWID, p_<<TYPE1:L>>_old IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE, p_<<TYPE1:L>>_new IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE) IS[[IF:CHILD(ATTRIBUTE:CHILD(ATTRIBUTE_DERIVATION_SOURCE:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
[[* Nu nog even voor recursief childs dit ook doen voor alle child records intern en extern *]]
		CURSOR c_<<TYPE1:L>> IS
			SELECT ROWID cube_row_id, <<TYPE1:L>>.* FROM v_<<TYPE:L>> <<TYPE1:L>>
			WHERE [[LOOP,ATTRIBUTE:1=Y[AND]3=F]]<<ATTRIBUTE:L>> = p_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>
			  AND [[ENDLOOP,ATTRIBUTE]][[LOOP,ATTRIBUTE:3=R]]<<ATTRIBUTE:L>> = p_<<TYPE1:L>>_old.[[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]][[IF:!LAST]]
			  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];
		
		l_<<TYPE1:L>>_rowid UROWID;
		r_<<TYPE1:L>>_old v_<<TYPE:L>>%ROWTYPE;
		r_<<TYPE1:L>>_new v_<<TYPE:L>>%ROWTYPE;[[ENDIF]]
	BEGIN[[IF:CHILD(ATTRIBUTE:<<TEXT,VIEW_CHANGEABLE_ATTRIBUTE>>)]][[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
		IF [[LOOP,ATTRIBUTE:3=R]]NVL(p_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE>>) <> NVL(p_<<TYPE1:L>>_new.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE>>) [[IF:!LAST]]
		OR [[ENDIF]][[ENDLOOP,ATTRIBUTE]] THEN
			get_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>>_new);
		END IF;[[ENDIF]]
		UPDATE t_<<TYPE:L>> SET [[LOOP,ATTRIBUTE:<<TEXT,VIEW_CHANGEABLE_ATTRIBUTE>>]]
			<<ATTRIBUTE:L>> = p_<<TYPE1:L>>_new.<<ATTRIBUTE:L>>[[IF:!LAST]],[[ENDIF]][[ENDLOOP,ATTRIBUTE]]
		WHERE rowid = p_cube_rowid;[[ELSE]]
		NULL;[[ENDIF]][[IF:CHILD(ATTRIBUTE:CHILD(ATTRIBUTE_DERIVATION_SOURCE:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
		IF [[LOOP,ATTRIBUTE:CHILD(ATTRIBUTE_DERIVATION_SOURCE:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>))]]NVL(p_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE>>) <> NVL(p_<<TYPE1:L>>_new.<<ATTRIBUTE:L>>,<<TEXT,GEN_NULL_VALUE>>)[[IF:!LAST]]
		OR [[ENDIF]][[ENDLOOP,ATTRIBUTE]] THEN
			OPEN c_<<TYPE1:L>>;
			LOOP
				FETCH c_<<TYPE1:L>> INTO
					l_<<TYPE1:L>>_rowid[[LOOP,ATTRIBUTE]],
					r_<<TYPE1:L>>_old.<<ATTRIBUTE:L>>[[ENDLOOP,ATTRIBUTE]];
				EXIT WHEN c_<<TYPE1:L>>%NOTFOUND;
				r_<<TYPE1:L>>_new := r_<<TYPE1:L>>_old;
				denorm_<<TYPE1:L>>_<<TYPE1:L>> (r_<<TYPE1:L>>_new, p_<<TYPE1:L>>_new);
				update_<<TYPE1:L>> (l_<<TYPE1:L>>_rowid, r_<<TYPE1:L>>_old, r_<<TYPE1:L>>_new);
			END LOOP;
			CLOSE c_<<TYPE1:L>>;
		END IF;[[ENDIF]]
	END;

	PROCEDURE delete_<<TYPE1:L>> (p_cube_rowid UROWID, p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE) IS
	BEGIN
		DELETE t_<<TYPE:L>> 
		WHERE rowid = p_cube_rowid;
	END;[[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>)))]]
[[* Nu nog even voor recursief parent dit ook doen voor alle parent records intern en extern *]]
	PROCEDURE denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE, p_<<TYPE1:L>>_in IN v_<<TYPE:L>>%ROWTYPE) IS
	BEGIN[[LOOP,ATTRIBUTE:CHILD(DERIVATION:0=DN[AND]CHILD(DERIVATION_TYPE:0=<<TYPE>>)[AND]CHILD(DERIVATION_TYPE_DESTINATION:0=<<TYPE>>))]]
		p_<<TYPE1:L>>.<<ATTRIBUTE:L>> := [[LOOP,DERIVATION]]<<TEXT,EXPRESSION[|]p_<<TYPE1:L>>_in[|]>>[[ENDLOOP,DERIVATION]];[[ENDLOOP,ATTRIBUTE]]
	END;

	PROCEDURE get_denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>> IN OUT NOCOPY v_<<TYPE:L>>%ROWTYPE) IS

		CURSOR c_<<TYPE1:L>> IS 
			SELECT * FROM v_<<TYPE:L>>
			WHERE [[LOOP,ATTRIBUTE:1=Y[AND]3=F]]<<ATTRIBUTE:L>> = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>
			  AND [[ENDLOOP,ATTRIBUTE]][[LOOP,ATTRIBUTE:3=R]][[LOOP,ATTRIBUTE_SOURCE]]<<ATTRIBUTE_SOURCE:L>>[[ENDLOOP,ATTRIBUTE_SOURCE]] = p_<<TYPE1:L>>.<<ATTRIBUTE:L>>[[IF:!LAST]]
			  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];
		
		r_<<TYPE1:L>> v_<<TYPE:L>>%ROWTYPE;
	BEGIN
		IF [[LOOP,ATTRIBUTE:3=R]]p_<<TYPE1:L>>.<<ATTRIBUTE:L>> IS NOT NULL[[IF:!LAST]] AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]] THEN
			OPEN c_<<TYPE1:L>>;
			FETCH c_<<TYPE1:L>> INTO r_<<TYPE1:L>>;
			IF c_<<TYPE1:L>>%NOTFOUND THEN
				r_<<TYPE1:L>> := NULL;
			END IF;
			CLOSE c_<<TYPE1:L>>;
		ELSE
			r_<<TYPE1:L>> := NULL;
		END IF;
		denorm_<<TYPE1:L>>_<<TYPE1:L>> (p_<<TYPE1:L>>, r_<<TYPE1:L>>);
	END;[[ENDIF]][[REPEAT]][[ENDLOOP,TYPE]]
END;
/
SHOW ERRORS;
[[LOOP,TYPE]]
CREATE OR REPLACE TRIGGER trg_<<TYPE1:L>>
INSTEAD OF INSERT OR DELETE OR UPDATE ON v_<<TYPE:L>>
FOR EACH ROW
DECLARE
	l_cube_rowid UROWID;
	r_<<TYPE1:L>>_new v_<<TYPE:L>>%ROWTYPE;
	r_<<TYPE1:L>>_old v_<<TYPE:L>>%ROWTYPE;
BEGIN
	IF INSERTING OR UPDATING THEN[[LOOP,ATTRIBUTE:!CHILD(DERIVATION:!0=SQ)]][[IF:CHILD(INFORMATION_TYPE_ELEMENT:2=TEXT[AND]7=N)]]
		IF :NEW.<<ATTRIBUTE:L>> = ' ' THEN
			r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := ' ';
		ELSE
			r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := REPLACE(:NEW.<<ATTRIBUTE:L>>,' ','_');
		END IF;[[ELSE]]
		r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := :NEW.<<ATTRIBUTE:L>>;[[ENDIF]][[ENDLOOP,ATTRIBUTE]]
	END IF;[[IF:CHILD(ATTRIBUTE:CHILD(DERIVATION:!0=SQ))]][[* In case of a derivation the old value is taken by default *]]
	IF UPDATING THEN[[LOOP,ATTRIBUTE:CHILD(DERIVATION:!0=SQ)]]
		r_<<TYPE1:L>>_new.<<ATTRIBUTE:L>> := :OLD.<<ATTRIBUTE:L>>;[[ENDLOOP,ATTRIBUTE]]
	END IF;[[ENDIF]]
	IF UPDATING OR DELETING THEN
		SELECT rowid INTO l_cube_rowid FROM t_<<TYPE:L>>
		WHERE [[LOOP,ATTRIBUTE:1=Y]]<<ATTRIBUTE:L>> = :OLD.<<ATTRIBUTE:L>>[[IF:!LAST]]
		  AND [[ENDIF]][[ENDLOOP,ATTRIBUTE]];[[LOOP,ATTRIBUTE:!CHILD(DERIVATION:!0=SQ)]]
		r_<<TYPE1:L>>_old.<<ATTRIBUTE:L>> := :OLD.<<ATTRIBUTE:L>>;[[ENDLOOP,ATTRIBUTE]]
	END IF;

	IF INSERTING THEN 
		pkg_<<TYPE(1)1:L>>_trg.insert_<<TYPE1:L>> (r_<<TYPE1:L>>_new);
	ELSIF UPDATING THEN
		pkg_<<TYPE(1)1:L>>_trg.update_<<TYPE1:L>> (l_cube_rowid, r_<<TYPE1:L>>_old, r_<<TYPE1:L>>_new);
	ELSIF DELETING THEN
		pkg_<<TYPE(1)1:L>>_trg.delete_<<TYPE1:L>> (l_cube_rowid, r_<<TYPE1:L>>_old);
	END IF;
END;
/
SHOW ERRORS
[[REPEAT]][[ENDLOOP,TYPE]][[ENDLOOP,BUSINESS_OBJECT_TYPE]][[ENDLOOP,SYSTEM_BO_TYPE]][[ENDLOOP,SYSTEM]]
EXIT;[[ENDBODY]]